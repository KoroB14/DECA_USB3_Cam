
#include "main.h"
#include "usb.h"
#include "cyfxgpif2config.h"				// File generated by GPIF Designer

CyBool_t glIsApplicationActive = CyFalse;
CyBool_t glForceLinkU2 = CyFalse;

CyU3PDmaChannel GPIF2USB_Handle, USB2GPIF_Handle;
CyU3PThread ThreadHandle;

void CheckStatus (CyU3PReturnStatus_t Status);
void CyFxApplicationDefine(void);
void ApplicationThread(uint32_t Value);
CyU3PReturnStatus_t InitializeUSB(void);
CyBool_t USBSetup_Callback(uint32_t setupdat0, uint32_t setupdat1);
void USBEvent_Callback(CyU3PUsbEventType_t Event, uint16_t EventData );
CyBool_t LPMRequest_Callback(CyU3PUsbLinkPowerMode link_mode);
void StartApplication(void);
void StopApplication(void);
CyU3PReturnStatus_t SetUSBdescriptors(void);
CyU3PReturnStatus_t StartGPIF(void);





// Set up the CPU environment and start the RTOS
int main (void)
{
    CyU3PSysClockConfig_t ClockConfig;
    CyU3PIoMatrixConfig_t io_Config;
    CyU3PReturnStatus_t Status;


    ClockConfig.setSysClk400  = CyTrue;
    ClockConfig.cpuClkDiv     = 2;
    ClockConfig.dmaClkDiv     = 2;
    ClockConfig.mmioClkDiv    = 2;
    ClockConfig.useStandbyClk = CyFalse;
    ClockConfig.clkSrc        = CY_U3P_SYS_CLK;
    Status = CyU3PDeviceInit(&ClockConfig);
    if (Status == CY_U3P_SUCCESS)
    {
		Status = CyU3PDeviceCacheControl(CyTrue, CyTrue, CyTrue);	// Icache, Dcache, DMAcache
		if (Status == CY_U3P_SUCCESS)
		{
			CyU3PMemSet((uint8_t *)&io_Config, 0, sizeof(io_Config));
			io_Config.isDQ32Bit = CyTrue;
			io_Config.useUart   = CyFalse;
			io_Config.lppMode   = CY_U3P_IO_MATRIX_LPP_DEFAULT;

			Status = CyU3PDeviceConfigureIOMatrix(&io_Config);
			if (Status == CY_U3P_SUCCESS) CyU3PKernelEntry();		// Start RTOS
		}
	}

    while (1);
	return 0;
}



// Function called by RTOS to startup the application threads
void CyFxApplicationDefine(void)
{
    void *StackPtr;
    uint32_t Status;

    StackPtr = CyU3PMemAlloc(APPLICATION_THREAD_STACK);
    Status = CyU3PThreadCreate(&ThreadHandle, 	// Handle to application Thread
            "11:app_thread",               	// Thread ID and name
            ApplicationThread,     				// Thread entry function
            0,                             	// Parameter passed to Thread
            StackPtr,                       	// Pointer to the allocated thread stack
            APPLICATION_THREAD_STACK,           // Allocated thread stack size
            APPLICATION_THREAD_PRIORITY,        // Thread priority
            APPLICATION_THREAD_PRIORITY,        // = Thread priority so no preemption
            CYU3P_NO_TIME_SLICE,            	// Time slice not supported
            CYU3P_AUTO_START                	// Start the thread immediately
            );

    if (Status != CY_U3P_SUCCESS)
    {
        // Thread creation failed with the Status = error code
        while(1)
        {
        	// Application cannot continue. Loop indefinitely
        }
    }
}

void CheckStatus (CyU3PReturnStatus_t Status)
{
    if (Status == CY_U3P_SUCCESS)
    {
    	return;
    }
    else
    {
        
        while(1)
        {
        	// Application cannot continue. Loop indefinitely
        }
    }

}


void ApplicationThread(uint32_t Value)
{

    CyU3PReturnStatus_t Status;

    Status = InitializeUSB();

    if (Status == CY_U3P_SUCCESS)
    {
		// Now run forever
    	while (1)
    	{

			CyU3PThreadSleep(100);

		}
    }
    

}



CyU3PReturnStatus_t InitializeUSB(void)
{
	CyU3PReturnStatus_t Status;
	CyBool_t NeedToRenumerate = CyTrue;
	Status = CyU3PUsbStart();
    if (Status == CY_U3P_ERROR_NO_REENUM_REQUIRED)
    {
    	NeedToRenumerate = CyFalse;
    	Status = CY_U3P_SUCCESS;
    }
	CheckStatus(Status);
	// Setup callbacks to handle the setup requests, USB Events and LPM Requests (for USB 3.0)
    CyU3PUsbRegisterSetupCallback(USBSetup_Callback, CyTrue);
    CyU3PUsbRegisterEventCallback(USBEvent_Callback);
    CyU3PUsbRegisterLPMRequestCallback(LPMRequest_Callback);

    // Set USB descriptors
    Status = SetUSBdescriptors();
    CheckStatus(Status);

    // Connect USB
    if (NeedToRenumerate)
    {
    	Status = CyU3PConnectState(CyTrue, CyTrue);
    	CheckStatus(Status);
    }
    else	// USB connection already exists, restart the Application
    {
        if (glIsApplicationActive) StopApplication();
        StartApplication();
    }

    return Status;
}


// Declare the callbacks needed to support the USB device driver
CyBool_t USBSetup_Callback(uint32_t setupdat0, uint32_t setupdat1)
{
	CyBool_t isHandled = CyFalse;
	union { uint32_t SetupData[2];
			struct { uint8_t Target:5; uint8_t Type:2; uint8_t Direction:1;
				 	 uint8_t Request; uint16_t Value; uint16_t Index; uint16_t Length; };
		  } Setup;

	Setup.SetupData[0] = setupdat0;
	Setup.SetupData[1] = setupdat1;

    if (Setup.Type == STANDARD_REQUEST)
    {
        /* Handle SET_FEATURE(FUNCTION_SUSPEND) and CLEAR_FEATURE(FUNCTION_SUSPEND)
         * requests here. It should be allowed to pass if the device is in configured
         * state and failed otherwise. */
        if ((Setup.Target == CY_U3P_USB_TARGET_INTF) && ((Setup.Request == CY_U3P_USB_SC_SET_FEATURE)
                    || (Setup.Request == CY_U3P_USB_SC_CLEAR_FEATURE)) && (Setup.Value == 0))
        {
            if (glIsApplicationActive)
            {
                CyU3PUsbAckSetup ();
                /* As we have only one interface, the link can be pushed into U2 state as soon as
                   this interface is suspended.
                 */
                glForceLinkU2 = (Setup.Request == CY_U3P_USB_SC_SET_FEATURE);
             }
            else CyU3PUsbStall(0, CyTrue, CyFalse);

            isHandled = CyTrue;
        }

        /* CLEAR_FEATURE request for endpoint is always passed to the setup callback
         * regardless of the enumeration model used. When a clear feature is received,
         * the previous transfer has to be flushed and cleaned up. This is done at the
         * protocol level. Since this is just a loopback operation, there is no higher
         * level protocol. So flush the EP memory and reset the DMA channel associated
         * with it. If there are more than one EP associated with the channel reset both
         * the EPs. The endpoint stall and toggle / sequence number is also expected to be
         * reset. Return CyFalse to make the library clear the stall and reset the endpoint
         * toggle. Or invoke the CyU3PUsbStall (ep, CyFalse, CyTrue) and return CyTrue.
         * Here we are clearing the stall. */
        if ((Setup.Target == CY_U3P_USB_TARGET_ENDPT) && (Setup.Request == CY_U3P_USB_SC_CLEAR_FEATURE)
                && (Setup.Value == CY_U3P_USBX_FS_EP_HALT))
        {
            if (glIsApplicationActive)
            {
                if (Setup.Index == USB_CONSUMER_ENDPOINT)
                {
                    CyU3PUsbStall(Setup.Index, CyFalse, CyTrue);
                    isHandled = CyTrue;
                    CyU3PUsbAckSetup();
                }
            }
        }
    }
    return isHandled;
}


void USBEvent_Callback(CyU3PUsbEventType_t Event, uint16_t EventData )
{

	switch (Event)
    {
     case CY_U3P_USB_EVENT_CONNECT:
       break;

    case CY_U3P_USB_EVENT_SETCONF:
        /* If the application is already active stop it before re-enabling. */
        if (glIsApplicationActive) StopApplication();

        StartApplication();
        break;

    case CY_U3P_USB_EVENT_DISCONNECT:
    case CY_U3P_USB_EVENT_RESET:
        glForceLinkU2 = CyFalse;
        if (glIsApplicationActive) StopApplication();
        break;

    case CY_U3P_USB_EVENT_EP_UNDERRUN:

        break;

    case CY_U3P_USB_EVENT_EP0_STAT_CPLT:

        break;

    default:
        break;
    }
}

CyBool_t LPMRequest_Callback(CyU3PUsbLinkPowerMode link_mode)
{
    return CyTrue;
}


void StartApplication(void)
// USB has been enumerated, start application
{
	CyU3PEpConfig_t epConfig;
	CyU3PDmaChannelConfig_t dmaConfig;
	CyU3PReturnStatus_t Status;
    CyU3PPibClock_t pibClock;
    const uint16_t EpSize[] = { 0, 64, 512, 1024 };
    CyU3PUSBSpeed_t usbSpeed = CyU3PUsbGetSpeed();
    uint32_t ClockValue = MAXCLOCKVALUE;


    // Start GPIF clocks, they need to be running before we attach a DMA channel to GPIF
    pibClock.clkDiv = ClockValue>>1;
    pibClock.clkSrc = CY_U3P_SYS_CLK;
    pibClock.isHalfDiv = (ClockValue & 1);
    pibClock.isDllEnable = CyFalse;		// Disable Dll since this application is synchronous
    Status = CyU3PPibInit(CyTrue, &pibClock);
    
 	CheckStatus(Status);


    // Based on the Bus Speed configure the endpoint packet size
	CyU3PMemSet((uint8_t *)&epConfig, 0, sizeof(epConfig));
	epConfig.enable = CyTrue;
	epConfig.epType = CY_U3P_USB_EP_BULK;
	epConfig.burstLen = (usbSpeed == CY_U3P_SUPER_SPEED) ? (ENDPOINT_BURST_LENGTH) : 1;
	epConfig.pcktSize = EpSize[usbSpeed];

	// Setup and flush the consumer endpoint
	Status = CyU3PSetEpConfig(USB_CONSUMER_ENDPOINT, &epConfig);
	CheckStatus(Status);
    

	// Create a AUTO channel for the GPIF to USB transfer, GPIF detects and COMMITs the last short packet
	CyU3PMemSet((uint8_t *)&dmaConfig, 0, sizeof(dmaConfig));
	dmaConfig.size           = DMA_BUFFER_SIZE;			// Use same size buffers for all USB Speeds
	dmaConfig.count          = DMA_BUFFER_COUNT;
	dmaConfig.prodSckId		 = GPIF_PRODUCER_SOCKET;
	dmaConfig.consSckId		 = USB_CONSUMER_ENDPOINT_SOCKET;
	dmaConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
	Status = CyU3PDmaChannelCreate(&GPIF2USB_Handle, CY_U3P_DMA_TYPE_AUTO, &dmaConfig);
	CheckStatus(Status);
    

	Status = CyU3PUsbFlushEp(USB_CONSUMER_ENDPOINT);
	CheckStatus(Status);
    

	// Start the DMA Channel with transfer size to Infinite
	Status = CyU3PDmaChannelSetXfer(&GPIF2USB_Handle, 0);
	CheckStatus(Status);
    

	// Setup and flush the producer endpoint
	epConfig.burstLen = 1;
	Status = CyU3PSetEpConfig(USB_PRODUCER_ENDPOINT, &epConfig);
	CheckStatus(Status);
    

	// Create a AUTO channel for the USB to GPIF transfer, USB detects and COMMITs the last short packet
	dmaConfig.size           = 1024;			
	dmaConfig.count          = 1;
	dmaConfig.prodSckId		 = USB_PRODUCER_ENDPOINT_SOCKET;
	dmaConfig.consSckId		 = GPIF_CONSUMER_SOCKET;
	dmaConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
	Status = CyU3PDmaChannelCreate(&USB2GPIF_Handle, CY_U3P_DMA_TYPE_AUTO, &dmaConfig);
	CheckStatus(Status);
    

	Status = CyU3PUsbFlushEp(USB_PRODUCER_ENDPOINT);
	CheckStatus(Status);

	// Start the DMA Channel with transfer size to Infinite
	Status = CyU3PDmaChannelSetXfer(&USB2GPIF_Handle, 0);
	CheckStatus(Status);

	// Load, configure and start the GPIF state machine
    Status = StartGPIF();
	CheckStatus(Status);
	Status = CyU3PUsbLPMDisable();
    // OK, Application can now run
    glIsApplicationActive = CyTrue;
}

void StopApplication(void)
// USB connection has been lost, stop the application
{
    CyU3PEpConfig_t epConfig;
    CyU3PReturnStatus_t Status;

    // Disable GPIF, close the DMA channels, flush and disable the endpoints
    CyU3PGpifDisable(CyTrue);
    Status = CyU3PPibDeInit();
    CheckStatus(Status);
    Status = CyU3PDmaChannelDestroy(&GPIF2USB_Handle);
    CheckStatus(Status);
    Status = CyU3PDmaChannelDestroy(&USB2GPIF_Handle);
    CheckStatus(Status);
    Status = CyU3PUsbFlushEp(USB_CONSUMER_ENDPOINT);
    CheckStatus(Status);
    Status = CyU3PUsbFlushEp(USB_PRODUCER_ENDPOINT);
    CheckStatus(Status);
	CyU3PMemSet((uint8_t *)&epConfig, 0, sizeof(&epConfig));
    Status = CyU3PSetEpConfig(USB_CONSUMER_ENDPOINT, &epConfig);
	CheckStatus(Status);
    Status = CyU3PSetEpConfig(USB_PRODUCER_ENDPOINT, &epConfig);
	CheckStatus(Status);

    // OK, Application is now stopped
    glIsApplicationActive = CyFalse;
}


CyU3PReturnStatus_t SetUSBdescriptors(void)
{
	CyU3PReturnStatus_t OverallStatus, Status;
	OverallStatus = Status = CyU3PUsbSetDesc(CY_U3P_USB_SET_SS_DEVICE_DESCR, 0, (uint8_t *)CyFxUSB30DeviceDscr);
    CheckStatus(Status);
    OverallStatus |= Status = CyU3PUsbSetDesc(CY_U3P_USB_SET_HS_DEVICE_DESCR, 0, (uint8_t *)CyFxUSB20DeviceDscr);
    CheckStatus(Status);
    OverallStatus |= Status = CyU3PUsbSetDesc(CY_U3P_USB_SET_SS_BOS_DESCR, 0, (uint8_t *)CyFxUSBBOSDscr);
    CheckStatus(Status);
    OverallStatus |= Status = CyU3PUsbSetDesc(CY_U3P_USB_SET_DEVQUAL_DESCR, 0, (uint8_t *)CyFxUSBDeviceQualDscr);
    CheckStatus(Status);
    OverallStatus |= Status = CyU3PUsbSetDesc(CY_U3P_USB_SET_SS_CONFIG_DESCR, 0, (uint8_t *)CyFxUSBSSConfigDscr);
    CheckStatus(Status);
    OverallStatus |= Status = CyU3PUsbSetDesc(CY_U3P_USB_SET_HS_CONFIG_DESCR, 0, (uint8_t *)CyFxUSBHSConfigDscr);
    CheckStatus(Status);
    OverallStatus |= Status = CyU3PUsbSetDesc(CY_U3P_USB_SET_FS_CONFIG_DESCR, 0, (uint8_t *)CyFxUSBFSConfigDscr);
    CheckStatus(Status);
    OverallStatus |= Status = CyU3PUsbSetDesc(CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
    CheckStatus(Status);
    OverallStatus |= Status = CyU3PUsbSetDesc(CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
    CheckStatus(Status);
    OverallStatus |= Status = CyU3PUsbSetDesc(CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
    CheckStatus(Status);

    return OverallStatus;
}


CyU3PReturnStatus_t StartGPIF(void)
{
	CyU3PReturnStatus_t Status;
	Status = CyU3PGpifLoad(&CyFxGpifConfig);

	CheckStatus(Status);
	Status = CyU3PGpifSocketConfigure(0, GPIF_PRODUCER_SOCKET, 4, CyFalse, 1); // set watermark
	CheckStatus(Status);
	Status = CyU3PGpifSocketConfigure(1, GPIF_CONSUMER_SOCKET, 3, CyFalse, 1); // set watermark
	CheckStatus(Status);
	Status = CyU3PGpifSMStart(START, ALPHA_START);
	return Status;
}
